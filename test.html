<html>

<head>

    <title>关于arguments、call、apply</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->

</head>

<body>
    <h1>模拟new object</h1>
    <pre >
            function Person(name) {
                this.name = name;
            };
            Person.prototype.getName = function () {
                return this.name;
            };
        
            var objectFactory = function () {
        
                console.log(arguments);
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log("遍历对象的可枚举属性，包括自有属性、继承自原型的属性")
                for (p in arguments) { // 遍历对象的可枚举属性，包括自有属性、继承自原型的属性
                    console.log(p)
                    console.log(arguments[p])
                    console.log("--------------")
                }
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log("Object.keys  对象自有的可枚举属性")
                console.log(Object.keys(arguments)); //对象自有的可枚举属性,
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log("Object.getOwnPropertyNames  返回对象的自有属性，包括可枚举和不可枚举的")
                console.log(Object.getOwnPropertyNames(arguments)); //返回对象的自有属性，包括可枚举和不可枚举的
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log("arguments['0']")
                console.log(arguments["0"])
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log("arguments['1']")
                console.log(arguments["1"])
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log('arguments["length"]')
                console.log(arguments["length"])
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
                console.log('arguments["callee"]')
                console.log(arguments["callee"])
                console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        
        
                //    var args = [];
                //     Array.prototype.push.apply( args, arguments );
                //     console.log(args);
        
                var obj = new Object(); // 从 Object.prototype上克隆一个空的对象
        
                //shift  返回数组原来的第一个元素的值。
                //call() 它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身
                //原本是对[]进行shift操作，由于call存在，shift的操作对象this指向了 arguments
                //arguments.shift(), 直接操作报错，因为arguments不是一个真正的数组
                //[],空数组，只是为了调用shift方法, 可以是任意数组，如[666,777,888]
                //其实相当于 Constructor = arguments[0]，区别在于，使用shift后，原对象arguments改变了
                var Constructor = [].shift.call(arguments); // 取得外部传入的构造器，此例是Person
        
                obj.__proto__ = Constructor.prototype;
                // 指向正确的原型
        
                //apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组
                //arguments 是被shift改变后的参数，去除了Person，只剩下参数
                var ret = Constructor.apply(obj, arguments); // 借用外部传入的构造器给obj设置属 性
        
        
                return typeof ret === 'object' ? ret : obj; // 确保构造器总是会返回一个对象
            };
            var a = objectFactory(Person, 'sven');
        
            console.log(Object.getPrototypeOf(a) === Person.prototype); // 输出：true


    </pre>

</body>
<script type="text/javascript">
    function Person(name) {
        this.name = name;
    };
    Person.prototype.getName = function () {
        return this.name;
    };

    var objectFactory = function () {

        console.log(arguments);
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log("遍历对象的可枚举属性，包括自有属性、继承自原型的属性")
        for (p in arguments) { // 遍历对象的可枚举属性，包括自有属性、继承自原型的属性
            console.log(p)
            console.log(arguments[p])
            console.log("--------------")
        }
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log("Object.keys  对象自有的可枚举属性")
        console.log(Object.keys(arguments)); //对象自有的可枚举属性,
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log("Object.getOwnPropertyNames  返回对象的自有属性，包括可枚举和不可枚举的")
        console.log(Object.getOwnPropertyNames(arguments)); //返回对象的自有属性，包括可枚举和不可枚举的
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log("arguments['0']")
        console.log(arguments["0"])
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log("arguments['1']")
        console.log(arguments["1"])
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log('arguments["length"]')
        console.log(arguments["length"])
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
        console.log('arguments["callee"]')
        console.log(arguments["callee"])
        console.log("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")


        //    var args = [];
        //     Array.prototype.push.apply( args, arguments );
        //     console.log(args);

        var obj = new Object(); // 从 Object.prototype上克隆一个空的对象

        //shift  返回数组原来的第一个元素的值。
        //call() 它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身
        //原本是对[]进行shift操作，由于call存在，shift的操作对象this指向了 arguments
        //arguments.shift(), 直接操作报错，因为arguments不是一个真正的数组
        //[],空数组，只是为了调用shift方法, 可以是任意数组，如[666,777,888]
        //其实相当于 Constructor = arguments[0]，区别在于，使用shift后，原对象arguments改变了
        var Constructor = [].shift.call(arguments); // 取得外部传入的构造器，此例是Person

        obj.__proto__ = Constructor.prototype;
        // 指向正确的原型

        //apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组
        //arguments 是被shift改变后的参数，去除了Person，只剩下参数
        var ret = Constructor.apply(obj, arguments); // 借用外部传入的构造器给obj设置属 性


        return typeof ret === 'object' ? ret : obj; // 确保构造器总是会返回一个对象
    };
    var a = objectFactory(Person, 'sven');

    console.log(Object.getPrototypeOf(a) === Person.prototype); // 输出：true


</script>

</html>